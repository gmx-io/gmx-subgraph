import { Address, BigInt, Bytes, ethereum } from "@graphprotocol/graph-ts"
import { PairFactory } from "../../generated/templates/PairReader/PairFactory"
import { ERC20 } from "../../generated/templates/PairReader/ERC20"
import { Swap } from "../../generated/templates/PairReader/Pair"

import { zero_address, createReferral, updateVolume, VolumeType } from "./utils"
import { Pair } from "../../generated/templates/PairReader/Pair"
import {
  PathToTarget,
  TotalVolumeTracker,
  DailyVolumeTracker,
  SwapLog
} from "../../generated/schema"
import { EACAggregatorProxy } from "../../generated/templates/PairReader/EACAggregatorProxy"
import { Dibs } from "../../generated/templates/PairReader/Dibs"
import {
  DIBS,
  DIBS_START_BLOCK,
  FACTORY,
  WETH,
  WETH_PRICE_FEED
} from "../../config/config"

export class SwapHandler {
  event: Swap
  pair: Pair
  pairFactory: PairFactory
  dibs: Dibs
  priceFeed: EACAggregatorProxy
  token0: Address
  amountIn0: BigInt
  token1: Address
  amountIn1: BigInt
  timestamp: BigInt

  user: Address
  parent: Address
  grandParent: Address

  constructor(event: Swap) {
    const dibs = getDibs()
    const pair = Pair.bind(event.address)

    const user = event.transaction.from

    this.event = event
    this.pair = pair
    this.dibs = dibs
    this.priceFeed = getWethPriceFeed()
    this.pairFactory = getFactory()
    this.token0 = pair.token0()
    this.token1 = pair.token1()
    this.amountIn0 = event.params.amount0In
    this.amountIn1 = event.params.amount1In

    this.timestamp = event.block.timestamp

    this.user = user

    if (event.block.number.gt(BigInt.fromI64(DIBS_START_BLOCK))) {
      const parent = dibs.parents(user)
      let grandParent = dibs.parents(parent)

      this.parent = parent

      // if the grandparent address is address 0x0, set grandparent address to dibs address
      if (grandParent == zero_address) {
        grandParent = dibs.codeToAddress(dibs.DIBS())
      }

      this.grandParent = grandParent
    } else {
      this.parent = Address.fromBytes(zero_address)
      this.grandParent = Address.fromBytes(zero_address)
    }
  }

  public handle(): void {
    this._handle0()
    this._handle1()
  }

  private _handle0(): void {
    if (this.amountIn0.gt(BigInt.fromI32(0)))
      this._handle(this.token0, this.amountIn0)
  }

  private _handle1(): void {
    if (this.amountIn1.gt(BigInt.fromI32(0)))
      this._handle(this.token1, this.amountIn1)
  }

  private _handle(token: Address, amountIn: BigInt): void {
    const volumeInWeth = this._getVolumeInWeth(token, amountIn)
    const volumeInDollars = this._getVolumeInDollars(volumeInWeth)

    this._updateTotalVolume(volumeInDollars) // track total volume generated by the platform

    if (
      this.event.block.number.gt(BigInt.fromI64(DIBS_START_BLOCK)) &&
      this._isRegisteredUser()
    ) {
      this._updateDibsVolume(volumeInDollars) // track total volume generated through dibs platform
      this._updateGeneratedVolumes(volumeInDollars) // track total volume generated by user, parent and grandparent
      createReferral(this.parent, this.user)
      this._createSwapLog(amountIn, token)
    }
  }

  private _createSwapLog(amountIn: BigInt, token: Address): void {
    const volumeInWeth = this._getVolumeInWeth(token, amountIn)
    const volumeInDollars = this._getVolumeInDollars(volumeInWeth)

    createSwapLog(
      this.event,
      this.user,
      token,
      amountIn,
      this.pair.stable(),
      volumeInWeth,
      this.priceFeed.latestAnswer(),
      volumeInDollars
    )
  }

  private _getVolumeInWeth(token: Address, amount: BigInt): BigInt {
    let volumeInWeth: BigInt
    const inputToken = ERC20.bind(token)
    const precision = 4

    const weth = Address.fromHexString(WETH)

    if (token == weth) {
      // if input token is wETH, no need to make conversions
      volumeInWeth = amount
    } else {
      // in case input token is not wETH
      const unit = BigInt.fromI32(10).pow(u8(inputToken.decimals() - precision))
      let unitVolumeInWeth: BigInt
      const pathToWeth = PathToTarget.load(token.toHex() + "-" + weth.toHex())

      if (pathToWeth == null) {
        // no route to wETH
        unitVolumeInWeth = BigInt.fromI32(0)
      } else {
        let _unit = unit
        let _token = token

        for (let i = 0; i < pathToWeth.path.length; i++) {
          const _pair = Pair.bind(Address.fromBytes(pathToWeth.path[i]))
          _unit = _pair.getAmountOut(_unit, _token)
          _token = token == _pair.token0() ? _pair.token1() : _pair.token0()
        }
        unitVolumeInWeth = _unit
      }

      volumeInWeth = unitVolumeInWeth.times(amount).div(unit) // time the amount of input token
    }
    return volumeInWeth
  }

  private _getVolumeInDollars(volumeInWeth: BigInt): BigInt {
    return this.priceFeed
      .latestAnswer()
      .times(volumeInWeth)
      .div(BigInt.fromI32(10).pow(u8(this.priceFeed.decimals())))
  }

  private _updateTotalVolume(volumeInDollars: BigInt): void {
    const totalVolumeTracker = this._getTotalVolumeTracker()
    totalVolumeTracker.totalVolume = totalVolumeTracker.totalVolume.plus(
      volumeInDollars
    )

    // update daily volume
    const dailyVolumeTracker = this._getDailyVolumeTracker()

    dailyVolumeTracker.totalVolume = dailyVolumeTracker.totalVolume.plus(
      volumeInDollars
    )

    totalVolumeTracker.save()
    dailyVolumeTracker.save()
  }

  private _getTotalVolumeTracker(): TotalVolumeTracker {
    let tracker = TotalVolumeTracker.load("0")

    if (tracker == null) {
      tracker = new TotalVolumeTracker("0")
      tracker.totalVolume = BigInt.fromI32(0)
      tracker.dibsVolume = BigInt.fromI32(0)
      tracker.save()
    }

    return tracker as TotalVolumeTracker
  }

  private _getDailyVolumeTracker(): DailyVolumeTracker {
    const day = this.event.block.timestamp
      .div(BigInt.fromI32(86400))
      .times(BigInt.fromI32(86400))

    let tracker = DailyVolumeTracker.load(day.toString())

    if (tracker == null) {
      tracker = new DailyVolumeTracker(day.toString())
      tracker.totalVolume = BigInt.fromI32(0)
      tracker.dibsVolume = BigInt.fromI32(0)
      tracker.day = day
      tracker.save()
    }

    return tracker as DailyVolumeTracker
  }

  private _updateDibsVolume(volumeInDollars: BigInt): void {
    const totalVolumeTracker = this._getTotalVolumeTracker()
    const dailyVolumeTracker = this._getDailyVolumeTracker()

    totalVolumeTracker.dibsVolume = totalVolumeTracker.dibsVolume.plus(
      volumeInDollars
    )

    dailyVolumeTracker.dibsVolume = dailyVolumeTracker.dibsVolume.plus(
      volumeInDollars
    )

    totalVolumeTracker.save()
    dailyVolumeTracker.save()
  }

  private _updateGeneratedVolumes(volumeInDollars: BigInt): void {
    updateVolume(
      this.user,
      volumeInDollars,
      this.timestamp,
      this.pair._address,
      VolumeType.USER
    )
    updateVolume(
      this.parent,
      volumeInDollars,
      this.timestamp,
      this.pair._address,
      VolumeType.PARENT
    )
    updateVolume(
      this.grandParent,
      volumeInDollars,
      this.timestamp,
      this.pair._address,
      VolumeType.GRANDPARENT
    )
  }

  private _isRegisteredUser(): boolean {
    // all registered users must have a non-zero parent
    return this.parent != zero_address
  }
}

function getWethPriceFeed(): EACAggregatorProxy {
  return EACAggregatorProxy.bind(Address.fromString(WETH_PRICE_FEED))
}

function getDibs(): Dibs {
  return Dibs.bind(Address.fromString(DIBS))
}

function getFactory(): PairFactory {
  return PairFactory.bind(Address.fromString(FACTORY))
}

function createSwapLog(
  event: Swap,
  user: Address,
  token: Address,
  amount: BigInt,
  isStable: boolean,
  volumeInBNB: BigInt,
  BNBPrice: BigInt,
  volumeInDollars: BigInt
): void {
  // log the swap itself
  let swap = new SwapLog(
    event.transaction.hash.toHex() +
      "-" +
      event.logIndex.toString() +
      "-" +
      token.toHex()
  )
  swap.txHash = event.transaction.hash
  swap.logIndex = event.logIndex
  swap.user = user
  swap.tokenIn = token
  swap.amountIn = amount
  swap.volumeInBNB = volumeInBNB
  swap.BNBPrice = BNBPrice
  swap.volumeInDollars = volumeInDollars
  swap.stable = isStable
  swap.timestamp = event.block.timestamp
  swap.save()
}

function e18(amount: BigInt): BigInt {
  const E18 = BigInt.fromI32(10).pow(18)
  return amount.times(E18)
}
